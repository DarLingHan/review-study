## new的一个过程
- 创建一个新对象
- 将构造函数的显示原型prototype指向这个新对象的隐式proto
- 将构造函数的属性方法复制给这个新对象
- 返回这个新对象（在没有返回值的情况下）

```javascript
    function myNew(Obj, ...args) {
        var obj = Object.create(Obj.prototype)
        Obj.apply(obj, args)
        return obj
    }

```
## ES5继承的几种方式
- 1. 原型链继承
    父类的实例作为子类的原型

    缺点： 无法传参；无法多继承

- 2. 构造函数继承
    在子类中执行构造函数

    缺点：不能继承原型上的属性和方法。

- 3. 组合继承
    在子类中执行构造函数
    并且将构造函数的实例作为子类的原型

    缺点：拷贝了两份实例

- 4. 寄生组合继承
    在子类中执行父类的构造函数
    新创建一个没有实例方法的类，将父类的原型复制给它，将这个新类的实例复制给子类的原型

    修复一下子类的constructor

    缺点：实现较为复杂

## ES6继承 extends

## ES5继承和ES6继承的区别
- ES5 实际上是先创建子类的实例对象this,再将父类的方法添加到this上
- ES6 实际上是先创建父类的实例对象，然后通过子类的构造函数去修改this
    子类当中是没有this对象的，而是继承了父类的this.所以必须在constructor中调用super()方法使用父类的this. super关键字其实就父类的实例